/* tslint:disable */
/* eslint-disable */
/**
 * AI-KYO
 * AI-KYO API description
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface AccessTokensDto
 */
export interface AccessTokensDto {
    /**
     * 
     * @type {string}
     * @memberof AccessTokensDto
     */
    'accessToken': string;
    /**
     * 
     * @type {string}
     * @memberof AccessTokensDto
     */
    'refreshToken': string;
}
/**
 * 
 * @export
 * @interface AskResetPasswordDto
 */
export interface AskResetPasswordDto {
    /**
     * 
     * @type {string}
     * @memberof AskResetPasswordDto
     */
    'email': string;
}
/**
 * 
 * @export
 * @interface CategoryDto
 */
export interface CategoryDto {
    /**
     * 
     * @type {string}
     * @memberof CategoryDto
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof CategoryDto
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface CheckIfEmailRegisteredResponseDto
 */
export interface CheckIfEmailRegisteredResponseDto {
    /**
     * 
     * @type {boolean}
     * @memberof CheckIfEmailRegisteredResponseDto
     */
    'isEmailAlreadyRegistered': boolean;
}
/**
 * 
 * @export
 * @interface CreateDocumentResponseDto
 */
export interface CreateDocumentResponseDto {
    /**
     * 
     * @type {string}
     * @memberof CreateDocumentResponseDto
     */
    'documentId': string;
}
/**
 * 
 * @export
 * @interface CreateFilterDto
 */
export interface CreateFilterDto {
    /**
     * 
     * @type {string}
     * @memberof CreateFilterDto
     */
    'kind': CreateFilterDtoKindEnum;
    /**
     * 
     * @type {string}
     * @memberof CreateFilterDto
     */
    'type'?: CreateFilterDtoTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof CreateFilterDto
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CreateFilterDto
     */
    'categoryId'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateFilterDto
     */
    'parentId'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof CreateFilterDto
     */
    'options'?: Array<string>;
}

export const CreateFilterDtoKindEnum = {
    Group: 'GROUP',
    Filter: 'FILTER'
} as const;

export type CreateFilterDtoKindEnum = typeof CreateFilterDtoKindEnum[keyof typeof CreateFilterDtoKindEnum];
export const CreateFilterDtoTypeEnum = {
    Date: 'DATE',
    Text: 'TEXT',
    SingleChoice: 'SINGLE_CHOICE',
    MultiChoice: 'MULTI_CHOICE',
    Year: 'YEAR',
    Integer: 'INTEGER'
} as const;

export type CreateFilterDtoTypeEnum = typeof CreateFilterDtoTypeEnum[keyof typeof CreateFilterDtoTypeEnum];

/**
 * 
 * @export
 * @interface CreateSavedSearchResponseDto
 */
export interface CreateSavedSearchResponseDto {
    /**
     * 
     * @type {string}
     * @memberof CreateSavedSearchResponseDto
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface DeleteDocumentsDto
 */
export interface DeleteDocumentsDto {
    /**
     * 
     * @type {Array<string>}
     * @memberof DeleteDocumentsDto
     */
    'ids': Array<string>;
}
/**
 * 
 * @export
 * @interface DocumentDateFilterValue
 */
export interface DocumentDateFilterValue {
    /**
     * 
     * @type {string}
     * @memberof DocumentDateFilterValue
     */
    'date': string;
}
/**
 * 
 * @export
 * @interface DocumentExportRequestDto
 */
export interface DocumentExportRequestDto {
    /**
     * 
     * @type {Array<string>}
     * @memberof DocumentExportRequestDto
     */
    'documentIds': Array<string>;
}
/**
 * 
 * @export
 * @interface DocumentFilterValueDto
 */
export interface DocumentFilterValueDto {
    /**
     * 
     * @type {string}
     * @memberof DocumentFilterValueDto
     */
    'type': DocumentFilterValueDtoTypeEnum;
    /**
     * 
     * @type {DocumentFilterValueDtoValue}
     * @memberof DocumentFilterValueDto
     */
    'value': DocumentFilterValueDtoValue;
    /**
     * 
     * @type {string}
     * @memberof DocumentFilterValueDto
     */
    'filterId': string;
}

export const DocumentFilterValueDtoTypeEnum = {
    Date: 'DATE',
    Text: 'TEXT',
    SingleChoice: 'SINGLE_CHOICE',
    MultiChoice: 'MULTI_CHOICE',
    Year: 'YEAR',
    Integer: 'INTEGER'
} as const;

export type DocumentFilterValueDtoTypeEnum = typeof DocumentFilterValueDtoTypeEnum[keyof typeof DocumentFilterValueDtoTypeEnum];

/**
 * @type DocumentFilterValueDtoValue
 * @export
 */
export type DocumentFilterValueDtoValue = DocumentDateFilterValue | DocumentIntegerFilterValue | DocumentMultichoiceFilterValue | DocumentSinglechoiceFilterValue | DocumentTextFilterValue | DocumentYearFilterValue;

/**
 * 
 * @export
 * @interface DocumentIntegerFilterValue
 */
export interface DocumentIntegerFilterValue {
    /**
     * 
     * @type {number}
     * @memberof DocumentIntegerFilterValue
     */
    'integer': number;
}
/**
 * 
 * @export
 * @interface DocumentMultichoiceFilterValue
 */
export interface DocumentMultichoiceFilterValue {
    /**
     * 
     * @type {Array<string>}
     * @memberof DocumentMultichoiceFilterValue
     */
    'choiceIds': Array<string>;
}
/**
 * 
 * @export
 * @interface DocumentSinglechoiceFilterValue
 */
export interface DocumentSinglechoiceFilterValue {
    /**
     * 
     * @type {string}
     * @memberof DocumentSinglechoiceFilterValue
     */
    'choiceId': string;
}
/**
 * 
 * @export
 * @interface DocumentTextFilterValue
 */
export interface DocumentTextFilterValue {
    /**
     * 
     * @type {string}
     * @memberof DocumentTextFilterValue
     */
    'text': string;
}
/**
 * 
 * @export
 * @interface DocumentYearFilterValue
 */
export interface DocumentYearFilterValue {
    /**
     * 
     * @type {number}
     * @memberof DocumentYearFilterValue
     */
    'year': number;
}
/**
 * 
 * @export
 * @interface FilterDto
 */
export interface FilterDto {
    /**
     * 
     * @type {string}
     * @memberof FilterDto
     */
    'kind': FilterDtoKindEnum;
    /**
     * 
     * @type {string}
     * @memberof FilterDto
     */
    'type'?: FilterDtoTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof FilterDto
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof FilterDto
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof FilterDto
     */
    'categoryId'?: string;
    /**
     * 
     * @type {string}
     * @memberof FilterDto
     */
    'parentId'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof FilterDto
     */
    'options'?: Array<string>;
}

export const FilterDtoKindEnum = {
    Group: 'GROUP',
    Filter: 'FILTER'
} as const;

export type FilterDtoKindEnum = typeof FilterDtoKindEnum[keyof typeof FilterDtoKindEnum];
export const FilterDtoTypeEnum = {
    Date: 'DATE',
    Text: 'TEXT',
    SingleChoice: 'SINGLE_CHOICE',
    MultiChoice: 'MULTI_CHOICE',
    Year: 'YEAR',
    Integer: 'INTEGER'
} as const;

export type FilterDtoTypeEnum = typeof FilterDtoTypeEnum[keyof typeof FilterDtoTypeEnum];

/**
 * 
 * @export
 * @interface FilterGroupWithMappingDto
 */
export interface FilterGroupWithMappingDto {
    /**
     * 
     * @type {{ [key: string]: FilterMappingEntry; }}
     * @memberof FilterGroupWithMappingDto
     */
    'mapping': { [key: string]: FilterMappingEntry; };
    /**
     * 
     * @type {FilterOrFilterGroupDto}
     * @memberof FilterGroupWithMappingDto
     */
    'filterGroup': FilterOrFilterGroupDto;
}
/**
 * 
 * @export
 * @interface FilterMappingEntry
 */
export interface FilterMappingEntry {
    /**
     * 
     * @type {string}
     * @memberof FilterMappingEntry
     */
    'type'?: FilterMappingEntryTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof FilterMappingEntry
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof FilterMappingEntry
     */
    'categoryId'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof FilterMappingEntry
     */
    'path': Array<string>;
}

export const FilterMappingEntryTypeEnum = {
    Date: 'DATE',
    Text: 'TEXT',
    SingleChoice: 'SINGLE_CHOICE',
    MultiChoice: 'MULTI_CHOICE',
    Year: 'YEAR',
    Integer: 'INTEGER'
} as const;

export type FilterMappingEntryTypeEnum = typeof FilterMappingEntryTypeEnum[keyof typeof FilterMappingEntryTypeEnum];

/**
 * 
 * @export
 * @interface FilterOrFilterGroupDto
 */
export interface FilterOrFilterGroupDto {
    /**
     * 
     * @type {string}
     * @memberof FilterOrFilterGroupDto
     */
    'kind': FilterOrFilterGroupDtoKindEnum;
    /**
     * 
     * @type {string}
     * @memberof FilterOrFilterGroupDto
     */
    'type'?: FilterOrFilterGroupDtoTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof FilterOrFilterGroupDto
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof FilterOrFilterGroupDto
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof FilterOrFilterGroupDto
     */
    'categoryId'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof FilterOrFilterGroupDto
     */
    'options'?: Array<string>;
    /**
     * 
     * @type {Array<FilterOrFilterGroupDto>}
     * @memberof FilterOrFilterGroupDto
     */
    'children'?: Array<FilterOrFilterGroupDto>;
}

export const FilterOrFilterGroupDtoKindEnum = {
    Group: 'GROUP',
    Filter: 'FILTER'
} as const;

export type FilterOrFilterGroupDtoKindEnum = typeof FilterOrFilterGroupDtoKindEnum[keyof typeof FilterOrFilterGroupDtoKindEnum];
export const FilterOrFilterGroupDtoTypeEnum = {
    Date: 'DATE',
    Text: 'TEXT',
    SingleChoice: 'SINGLE_CHOICE',
    MultiChoice: 'MULTI_CHOICE',
    Year: 'YEAR',
    Integer: 'INTEGER'
} as const;

export type FilterOrFilterGroupDtoTypeEnum = typeof FilterOrFilterGroupDtoTypeEnum[keyof typeof FilterOrFilterGroupDtoTypeEnum];

/**
 * 
 * @export
 * @interface ImageDto
 */
export interface ImageDto {
    /**
     * 
     * @type {number}
     * @memberof ImageDto
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof ImageDto
     */
    'url': string;
    /**
     * 
     * @type {string}
     * @memberof ImageDto
     */
    'documentId': string;
    /**
     * 
     * @type {number}
     * @memberof ImageDto
     */
    'searchId': number;
    /**
     * 
     * @type {Array<number>}
     * @memberof ImageDto
     */
    'embedding': Array<number>;
}
/**
 * 
 * @export
 * @interface IndexationStatusDto
 */
export interface IndexationStatusDto {
    /**
     * 
     * @type {string}
     * @memberof IndexationStatusDto
     */
    'status': IndexationStatusDtoStatusEnum;
}

export const IndexationStatusDtoStatusEnum = {
    Processing: 'PROCESSING',
    Indexed: 'INDEXED',
    Error: 'ERROR'
} as const;

export type IndexationStatusDtoStatusEnum = typeof IndexationStatusDtoStatusEnum[keyof typeof IndexationStatusDtoStatusEnum];

/**
 * 
 * @export
 * @interface IsAuthenticatedDto
 */
export interface IsAuthenticatedDto {
    /**
     * 
     * @type {boolean}
     * @memberof IsAuthenticatedDto
     */
    'isAuthenticated': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof IsAuthenticatedDto
     */
    'isEmailValidated'?: boolean;
}
/**
 * 
 * @export
 * @interface RefinementFilterDto
 */
export interface RefinementFilterDto {
    /**
     * 
     * @type {FilterOrFilterGroupDto}
     * @memberof RefinementFilterDto
     */
    'filter': FilterOrFilterGroupDto;
    /**
     * 
     * @type {Array<ValueCount>}
     * @memberof RefinementFilterDto
     */
    'counts': Array<ValueCount>;
}
/**
 * 
 * @export
 * @interface RefreshTokenDto
 */
export interface RefreshTokenDto {
    /**
     * 
     * @type {string}
     * @memberof RefreshTokenDto
     */
    'refreshToken': string;
}
/**
 * 
 * @export
 * @interface ResetPasswordDto
 */
export interface ResetPasswordDto {
    /**
     * 
     * @type {string}
     * @memberof ResetPasswordDto
     */
    'token': string;
    /**
     * 
     * @type {string}
     * @memberof ResetPasswordDto
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface SavedSearchDto
 */
export interface SavedSearchDto {
    /**
     * 
     * @type {Array<SearchQueryDtoFilterValuesInner>}
     * @memberof SavedSearchDto
     */
    'filterValues': Array<SearchQueryDtoFilterValuesInner>;
    /**
     * 
     * @type {string}
     * @memberof SavedSearchDto
     */
    'monitoringFrequency': SavedSearchDtoMonitoringFrequencyEnum;
    /**
     * 
     * @type {number}
     * @memberof SavedSearchDto
     */
    'id': number;
    /**
     * 
     * @type {boolean}
     * @memberof SavedSearchDto
     */
    'isMonitored': boolean;
    /**
     * 
     * @type {string}
     * @memberof SavedSearchDto
     */
    'categoryId': string;
    /**
     * 
     * @type {string}
     * @memberof SavedSearchDto
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof SavedSearchDto
     */
    'text': string;
    /**
     * 
     * @type {Array<ImageDto>}
     * @memberof SavedSearchDto
     */
    'images': Array<ImageDto>;
}

export const SavedSearchDtoMonitoringFrequencyEnum = {
    Daily: 'DAILY',
    Weekly: 'WEEKLY',
    Monthly: 'MONTHLY'
} as const;

export type SavedSearchDtoMonitoringFrequencyEnum = typeof SavedSearchDtoMonitoringFrequencyEnum[keyof typeof SavedSearchDtoMonitoringFrequencyEnum];

/**
 * 
 * @export
 * @interface SearchQueryDateFilterValue
 */
export interface SearchQueryDateFilterValue {
    /**
     * 
     * @type {string}
     * @memberof SearchQueryDateFilterValue
     */
    'type': SearchQueryDateFilterValueTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof SearchQueryDateFilterValue
     */
    'mode'?: SearchQueryDateFilterValueModeEnum;
    /**
     * 
     * @type {string}
     * @memberof SearchQueryDateFilterValue
     */
    'firstDate': string;
    /**
     * 
     * @type {string}
     * @memberof SearchQueryDateFilterValue
     */
    'secondDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof SearchQueryDateFilterValue
     */
    'filterId': string;
}

export const SearchQueryDateFilterValueTypeEnum = {
    Date: 'DATE',
    Text: 'TEXT',
    SingleChoice: 'SINGLE_CHOICE',
    MultiChoice: 'MULTI_CHOICE',
    Year: 'YEAR',
    Integer: 'INTEGER'
} as const;

export type SearchQueryDateFilterValueTypeEnum = typeof SearchQueryDateFilterValueTypeEnum[keyof typeof SearchQueryDateFilterValueTypeEnum];
export const SearchQueryDateFilterValueModeEnum = {
    Equal: 'EQUAL',
    Before: 'BEFORE',
    After: 'AFTER',
    BeforeOrEqual: 'BEFORE_OR_EQUAL',
    AfterOrEqual: 'AFTER_OR_EQUAL'
} as const;

export type SearchQueryDateFilterValueModeEnum = typeof SearchQueryDateFilterValueModeEnum[keyof typeof SearchQueryDateFilterValueModeEnum];

/**
 * @type SearchQueryDtoFilterValuesInner
 * @export
 */
export type SearchQueryDtoFilterValuesInner = SearchQueryDateFilterValue | SearchQueryIntegerFilterValue | SearchQueryMultichoiceFilterValue | SearchQuerySinglechoiceFilterValue | SearchQueryTextFilterValue | SearchQueryYearFilterValue;

/**
 * 
 * @export
 * @interface SearchQueryIntegerFilterValue
 */
export interface SearchQueryIntegerFilterValue {
    /**
     * 
     * @type {string}
     * @memberof SearchQueryIntegerFilterValue
     */
    'type': SearchQueryIntegerFilterValueTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof SearchQueryIntegerFilterValue
     */
    'mode'?: SearchQueryIntegerFilterValueModeEnum;
    /**
     * 
     * @type {number}
     * @memberof SearchQueryIntegerFilterValue
     */
    'firstInteger': number;
    /**
     * 
     * @type {number}
     * @memberof SearchQueryIntegerFilterValue
     */
    'secondInteger'?: number;
    /**
     * 
     * @type {string}
     * @memberof SearchQueryIntegerFilterValue
     */
    'filterId': string;
}

export const SearchQueryIntegerFilterValueTypeEnum = {
    Date: 'DATE',
    Text: 'TEXT',
    SingleChoice: 'SINGLE_CHOICE',
    MultiChoice: 'MULTI_CHOICE',
    Year: 'YEAR',
    Integer: 'INTEGER'
} as const;

export type SearchQueryIntegerFilterValueTypeEnum = typeof SearchQueryIntegerFilterValueTypeEnum[keyof typeof SearchQueryIntegerFilterValueTypeEnum];
export const SearchQueryIntegerFilterValueModeEnum = {
    Equal: 'EQUAL',
    Before: 'BEFORE',
    After: 'AFTER',
    BeforeOrEqual: 'BEFORE_OR_EQUAL',
    AfterOrEqual: 'AFTER_OR_EQUAL'
} as const;

export type SearchQueryIntegerFilterValueModeEnum = typeof SearchQueryIntegerFilterValueModeEnum[keyof typeof SearchQueryIntegerFilterValueModeEnum];

/**
 * 
 * @export
 * @interface SearchQueryMultichoiceFilterValue
 */
export interface SearchQueryMultichoiceFilterValue {
    /**
     * 
     * @type {string}
     * @memberof SearchQueryMultichoiceFilterValue
     */
    'type': SearchQueryMultichoiceFilterValueTypeEnum;
    /**
     * 
     * @type {Array<string>}
     * @memberof SearchQueryMultichoiceFilterValue
     */
    'choiceIds': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof SearchQueryMultichoiceFilterValue
     */
    'filterId': string;
}

export const SearchQueryMultichoiceFilterValueTypeEnum = {
    Date: 'DATE',
    Text: 'TEXT',
    SingleChoice: 'SINGLE_CHOICE',
    MultiChoice: 'MULTI_CHOICE',
    Year: 'YEAR',
    Integer: 'INTEGER'
} as const;

export type SearchQueryMultichoiceFilterValueTypeEnum = typeof SearchQueryMultichoiceFilterValueTypeEnum[keyof typeof SearchQueryMultichoiceFilterValueTypeEnum];

/**
 * 
 * @export
 * @interface SearchQuerySinglechoiceFilterValue
 */
export interface SearchQuerySinglechoiceFilterValue {
    /**
     * 
     * @type {string}
     * @memberof SearchQuerySinglechoiceFilterValue
     */
    'type': SearchQuerySinglechoiceFilterValueTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof SearchQuerySinglechoiceFilterValue
     */
    'choiceId': string;
    /**
     * 
     * @type {string}
     * @memberof SearchQuerySinglechoiceFilterValue
     */
    'filterId': string;
}

export const SearchQuerySinglechoiceFilterValueTypeEnum = {
    Date: 'DATE',
    Text: 'TEXT',
    SingleChoice: 'SINGLE_CHOICE',
    MultiChoice: 'MULTI_CHOICE',
    Year: 'YEAR',
    Integer: 'INTEGER'
} as const;

export type SearchQuerySinglechoiceFilterValueTypeEnum = typeof SearchQuerySinglechoiceFilterValueTypeEnum[keyof typeof SearchQuerySinglechoiceFilterValueTypeEnum];

/**
 * 
 * @export
 * @interface SearchQueryTextFilterValue
 */
export interface SearchQueryTextFilterValue {
    /**
     * 
     * @type {string}
     * @memberof SearchQueryTextFilterValue
     */
    'type': SearchQueryTextFilterValueTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof SearchQueryTextFilterValue
     */
    'mode': SearchQueryTextFilterValueModeEnum;
    /**
     * 
     * @type {string}
     * @memberof SearchQueryTextFilterValue
     */
    'text'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof SearchQueryTextFilterValue
     */
    'negate': boolean;
    /**
     * 
     * @type {string}
     * @memberof SearchQueryTextFilterValue
     */
    'filterId': string;
}

export const SearchQueryTextFilterValueTypeEnum = {
    Date: 'DATE',
    Text: 'TEXT',
    SingleChoice: 'SINGLE_CHOICE',
    MultiChoice: 'MULTI_CHOICE',
    Year: 'YEAR',
    Integer: 'INTEGER'
} as const;

export type SearchQueryTextFilterValueTypeEnum = typeof SearchQueryTextFilterValueTypeEnum[keyof typeof SearchQueryTextFilterValueTypeEnum];
export const SearchQueryTextFilterValueModeEnum = {
    Equal: 'EQUAL',
    Contains: 'CONTAINS',
    Startswith: 'STARTSWITH',
    Endswith: 'ENDSWITH',
    Isnull: 'ISNULL',
    Isin: 'ISIN'
} as const;

export type SearchQueryTextFilterValueModeEnum = typeof SearchQueryTextFilterValueModeEnum[keyof typeof SearchQueryTextFilterValueModeEnum];

/**
 * 
 * @export
 * @interface SearchQueryYearFilterValue
 */
export interface SearchQueryYearFilterValue {
    /**
     * 
     * @type {string}
     * @memberof SearchQueryYearFilterValue
     */
    'type': SearchQueryYearFilterValueTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof SearchQueryYearFilterValue
     */
    'mode'?: SearchQueryYearFilterValueModeEnum;
    /**
     * 
     * @type {number}
     * @memberof SearchQueryYearFilterValue
     */
    'firstYear': number;
    /**
     * 
     * @type {number}
     * @memberof SearchQueryYearFilterValue
     */
    'secondYear'?: number;
    /**
     * 
     * @type {string}
     * @memberof SearchQueryYearFilterValue
     */
    'filterId': string;
}

export const SearchQueryYearFilterValueTypeEnum = {
    Date: 'DATE',
    Text: 'TEXT',
    SingleChoice: 'SINGLE_CHOICE',
    MultiChoice: 'MULTI_CHOICE',
    Year: 'YEAR',
    Integer: 'INTEGER'
} as const;

export type SearchQueryYearFilterValueTypeEnum = typeof SearchQueryYearFilterValueTypeEnum[keyof typeof SearchQueryYearFilterValueTypeEnum];
export const SearchQueryYearFilterValueModeEnum = {
    Equal: 'EQUAL',
    Before: 'BEFORE',
    After: 'AFTER',
    BeforeOrEqual: 'BEFORE_OR_EQUAL',
    AfterOrEqual: 'AFTER_OR_EQUAL'
} as const;

export type SearchQueryYearFilterValueModeEnum = typeof SearchQueryYearFilterValueModeEnum[keyof typeof SearchQueryYearFilterValueModeEnum];

/**
 * 
 * @export
 * @interface SearchResultDto
 */
export interface SearchResultDto {
    /**
     * 
     * @type {Array<SearchQueryDtoFilterValuesInner>}
     * @memberof SearchResultDto
     */
    'filterValues': Array<SearchQueryDtoFilterValuesInner>;
    /**
     * 
     * @type {string}
     * @memberof SearchResultDto
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof SearchResultDto
     */
    'filename': string;
    /**
     * 
     * @type {string}
     * @memberof SearchResultDto
     */
    'url': string;
    /**
     * 
     * @type {string}
     * @memberof SearchResultDto
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof SearchResultDto
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof SearchResultDto
     */
    'categoryId': string;
    /**
     * 
     * @type {number}
     * @memberof SearchResultDto
     */
    'score'?: number;
    /**
     * 
     * @type {object}
     * @memberof SearchResultDto
     */
    'category': object;
    /**
     * 
     * @type {Array<ImageDto>}
     * @memberof SearchResultDto
     */
    'images': Array<ImageDto>;
    /**
     * 
     * @type {string}
     * @memberof SearchResultDto
     */
    'creatorId': string;
    /**
     * 
     * @type {string}
     * @memberof SearchResultDto
     */
    'editorId': string;
    /**
     * 
     * @type {object}
     * @memberof SearchResultDto
     */
    'status': object;
}
/**
 * 
 * @export
 * @interface SearchResultsWithRefinementFiltersDto
 */
export interface SearchResultsWithRefinementFiltersDto {
    /**
     * 
     * @type {Array<SearchResultDto>}
     * @memberof SearchResultsWithRefinementFiltersDto
     */
    'searchResults': Array<SearchResultDto>;
    /**
     * 
     * @type {number}
     * @memberof SearchResultsWithRefinementFiltersDto
     */
    'total': number;
    /**
     * 
     * @type {boolean}
     * @memberof SearchResultsWithRefinementFiltersDto
     */
    'moreThan': boolean;
    /**
     * 
     * @type {Array<RefinementFilterDto>}
     * @memberof SearchResultsWithRefinementFiltersDto
     */
    'refinementFilters': Array<RefinementFilterDto>;
    /**
     * 
     * @type {boolean}
     * @memberof SearchResultsWithRefinementFiltersDto
     */
    'isSavedSearch': boolean;
}
/**
 * 
 * @export
 * @interface SignInDto
 */
export interface SignInDto {
    /**
     * 
     * @type {string}
     * @memberof SignInDto
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof SignInDto
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface SignOutDto
 */
export interface SignOutDto {
    /**
     * 
     * @type {string}
     * @memberof SignOutDto
     */
    'accessToken': string;
    /**
     * 
     * @type {string}
     * @memberof SignOutDto
     */
    'refreshToken': string;
}
/**
 * 
 * @export
 * @interface SignUpDto
 */
export interface SignUpDto {
    /**
     * 
     * @type {string}
     * @memberof SignUpDto
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof SignUpDto
     */
    'firstName': string;
    /**
     * 
     * @type {string}
     * @memberof SignUpDto
     */
    'lastName': string;
    /**
     * 
     * @type {string}
     * @memberof SignUpDto
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface UpdateDocumentDto
 */
export interface UpdateDocumentDto {
    /**
     * 
     * @type {Array<DocumentFilterValueDto>}
     * @memberof UpdateDocumentDto
     */
    'filters': Array<DocumentFilterValueDto>;
    /**
     * 
     * @type {Array<string>}
     * @memberof UpdateDocumentDto
     */
    'ids': Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateDocumentDto
     */
    'deletePreviousFilters': boolean;
}
/**
 * 
 * @export
 * @interface UpdateFilterDto
 */
export interface UpdateFilterDto {
    /**
     * 
     * @type {string}
     * @memberof UpdateFilterDto
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof UpdateFilterDto
     */
    'parentId'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof UpdateFilterDto
     */
    'newOptions'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof UpdateFilterDto
     */
    'categoryId'?: string;
}
/**
 * 
 * @export
 * @interface UpdatePersonalEmailResponseDto
 */
export interface UpdatePersonalEmailResponseDto {
    /**
     * 
     * @type {boolean}
     * @memberof UpdatePersonalEmailResponseDto
     */
    'success': boolean;
}
/**
 * 
 * @export
 * @interface UpdateSavedSearchDto
 */
export interface UpdateSavedSearchDto {
    /**
     * 
     * @type {string}
     * @memberof UpdateSavedSearchDto
     */
    'monitoringFrequency'?: UpdateSavedSearchDtoMonitoringFrequencyEnum;
    /**
     * 
     * @type {string}
     * @memberof UpdateSavedSearchDto
     */
    'name': string;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateSavedSearchDto
     */
    'isMonitored': boolean;
}

export const UpdateSavedSearchDtoMonitoringFrequencyEnum = {
    Daily: 'DAILY',
    Weekly: 'WEEKLY',
    Monthly: 'MONTHLY'
} as const;

export type UpdateSavedSearchDtoMonitoringFrequencyEnum = typeof UpdateSavedSearchDtoMonitoringFrequencyEnum[keyof typeof UpdateSavedSearchDtoMonitoringFrequencyEnum];

/**
 * 
 * @export
 * @interface UpdateUserPermissionsDto
 */
export interface UpdateUserPermissionsDto {
    /**
     * 
     * @type {string}
     * @memberof UpdateUserPermissionsDto
     */
    'newRole': UpdateUserPermissionsDtoNewRoleEnum;
    /**
     * 
     * @type {string}
     * @memberof UpdateUserPermissionsDto
     */
    'newStatus': UpdateUserPermissionsDtoNewStatusEnum;
}

export const UpdateUserPermissionsDtoNewRoleEnum = {
    User: 'USER',
    Operator: 'OPERATOR',
    Admin: 'ADMIN'
} as const;

export type UpdateUserPermissionsDtoNewRoleEnum = typeof UpdateUserPermissionsDtoNewRoleEnum[keyof typeof UpdateUserPermissionsDtoNewRoleEnum];
export const UpdateUserPermissionsDtoNewStatusEnum = {
    Active: 'ACTIVE',
    Deactivated: 'DEACTIVATED'
} as const;

export type UpdateUserPermissionsDtoNewStatusEnum = typeof UpdateUserPermissionsDtoNewStatusEnum[keyof typeof UpdateUserPermissionsDtoNewStatusEnum];

/**
 * 
 * @export
 * @interface UpdateUserProfileDto
 */
export interface UpdateUserProfileDto {
    /**
     * 
     * @type {string}
     * @memberof UpdateUserProfileDto
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateUserProfileDto
     */
    'firstName'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateUserProfileDto
     */
    'lastName'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateUserProfileDto
     */
    'currentPassword'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateUserProfileDto
     */
    'newPassword'?: string;
}
/**
 * 
 * @export
 * @interface UpdateUserProfileResponseDto
 */
export interface UpdateUserProfileResponseDto {
    /**
     * 
     * @type {boolean}
     * @memberof UpdateUserProfileResponseDto
     */
    'hasVerificationEmailBeenSent'?: boolean;
}
/**
 * 
 * @export
 * @interface UserProfileDto
 */
export interface UserProfileDto {
    /**
     * 
     * @type {string}
     * @memberof UserProfileDto
     */
    'role': UserProfileDtoRoleEnum;
    /**
     * 
     * @type {string}
     * @memberof UserProfileDto
     */
    'status': UserProfileDtoStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof UserProfileDto
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof UserProfileDto
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof UserProfileDto
     */
    'firstName': string;
    /**
     * 
     * @type {string}
     * @memberof UserProfileDto
     */
    'lastName': string;
    /**
     * 
     * @type {boolean}
     * @memberof UserProfileDto
     */
    'isEmailValidated': boolean;
}

export const UserProfileDtoRoleEnum = {
    User: 'USER',
    Operator: 'OPERATOR',
    Admin: 'ADMIN'
} as const;

export type UserProfileDtoRoleEnum = typeof UserProfileDtoRoleEnum[keyof typeof UserProfileDtoRoleEnum];
export const UserProfileDtoStatusEnum = {
    Active: 'ACTIVE',
    Deactivated: 'DEACTIVATED'
} as const;

export type UserProfileDtoStatusEnum = typeof UserProfileDtoStatusEnum[keyof typeof UserProfileDtoStatusEnum];

/**
 * 
 * @export
 * @interface ValueCount
 */
export interface ValueCount {
    /**
     * 
     * @type {string}
     * @memberof ValueCount
     */
    'value': string;
    /**
     * 
     * @type {number}
     * @memberof ValueCount
     */
    'count': number;
}

/**
 * AdminApi - axios parameter creator
 * @export
 */
export const AdminApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} searchText 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminControllerFindAllUsers: async (searchText: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'searchText' is not null or undefined
            assertParamExists('adminControllerFindAllUsers', 'searchText', searchText)
            const localVarPath = `/api/v1/admin`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (searchText !== undefined) {
                localVarQueryParameter['searchText'] = searchText;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateUserPermissionsDto} updateUserPermissionsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminControllerUpdateUserPermissions: async (id: string, updateUserPermissionsDto: UpdateUserPermissionsDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('adminControllerUpdateUserPermissions', 'id', id)
            // verify required parameter 'updateUserPermissionsDto' is not null or undefined
            assertParamExists('adminControllerUpdateUserPermissions', 'updateUserPermissionsDto', updateUserPermissionsDto)
            const localVarPath = `/api/v1/admin/user-permissions/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateUserPermissionsDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AdminApi - functional programming interface
 * @export
 */
export const AdminApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AdminApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} searchText 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminControllerFindAllUsers(searchText: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserProfileDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminControllerFindAllUsers(searchText, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['AdminApi.adminControllerFindAllUsers']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateUserPermissionsDto} updateUserPermissionsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminControllerUpdateUserPermissions(id: string, updateUserPermissionsDto: UpdateUserPermissionsDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminControllerUpdateUserPermissions(id, updateUserPermissionsDto, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['AdminApi.adminControllerUpdateUserPermissions']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * AdminApi - factory interface
 * @export
 */
export const AdminApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AdminApiFp(configuration)
    return {
        /**
         * 
         * @param {string} searchText 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminControllerFindAllUsers(searchText: string, options?: any): AxiosPromise<Array<UserProfileDto>> {
            return localVarFp.adminControllerFindAllUsers(searchText, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateUserPermissionsDto} updateUserPermissionsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminControllerUpdateUserPermissions(id: string, updateUserPermissionsDto: UpdateUserPermissionsDto, options?: any): AxiosPromise<void> {
            return localVarFp.adminControllerUpdateUserPermissions(id, updateUserPermissionsDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AdminApi - object-oriented interface
 * @export
 * @class AdminApi
 * @extends {BaseAPI}
 */
export class AdminApi extends BaseAPI {
    /**
     * 
     * @param {string} searchText 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public adminControllerFindAllUsers(searchText: string, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).adminControllerFindAllUsers(searchText, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {UpdateUserPermissionsDto} updateUserPermissionsDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public adminControllerUpdateUserPermissions(id: string, updateUserPermissionsDto: UpdateUserPermissionsDto, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).adminControllerUpdateUserPermissions(id, updateUserPermissionsDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AuthenticationApi - axios parameter creator
 * @export
 */
export const AuthenticationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {AskResetPasswordDto} askResetPasswordDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authenticationControllerAskResetPassword: async (askResetPasswordDto: AskResetPasswordDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'askResetPasswordDto' is not null or undefined
            assertParamExists('authenticationControllerAskResetPassword', 'askResetPasswordDto', askResetPasswordDto)
            const localVarPath = `/api/v1/authentication/ask-reset-password`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(askResetPasswordDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authenticationControllerCheckIfAuthenticated: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/authentication/is-authenticated`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} email 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authenticationControllerCheckIfEmailRegistered: async (email: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'email' is not null or undefined
            assertParamExists('authenticationControllerCheckIfEmailRegistered', 'email', email)
            const localVarPath = `/api/v1/authentication/check-if-email-registered`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (email !== undefined) {
                localVarQueryParameter['email'] = email;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authenticationControllerConfirmProfileEmailUpdate: async (token: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('authenticationControllerConfirmProfileEmailUpdate', 'token', token)
            const localVarPath = `/api/v1/authentication/update-personal-email`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {RefreshTokenDto} refreshTokenDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authenticationControllerRefreshTokens: async (refreshTokenDto: RefreshTokenDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'refreshTokenDto' is not null or undefined
            assertParamExists('authenticationControllerRefreshTokens', 'refreshTokenDto', refreshTokenDto)
            const localVarPath = `/api/v1/authentication/refresh-tokens`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(refreshTokenDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authenticationControllerResendValidationEmail: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/authentication/resend-validation-email`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ResetPasswordDto} resetPasswordDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authenticationControllerResetPassword: async (resetPasswordDto: ResetPasswordDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'resetPasswordDto' is not null or undefined
            assertParamExists('authenticationControllerResetPassword', 'resetPasswordDto', resetPasswordDto)
            const localVarPath = `/api/v1/authentication/reset-password`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(resetPasswordDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SignInDto} signInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authenticationControllerSignIn: async (signInDto: SignInDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'signInDto' is not null or undefined
            assertParamExists('authenticationControllerSignIn', 'signInDto', signInDto)
            const localVarPath = `/api/v1/authentication/sign-in`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(signInDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SignOutDto} signOutDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authenticationControllerSignOut: async (signOutDto: SignOutDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'signOutDto' is not null or undefined
            assertParamExists('authenticationControllerSignOut', 'signOutDto', signOutDto)
            const localVarPath = `/api/v1/authentication/sign-out`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(signOutDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SignUpDto} signUpDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authenticationControllerSignUp: async (signUpDto: SignUpDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'signUpDto' is not null or undefined
            assertParamExists('authenticationControllerSignUp', 'signUpDto', signUpDto)
            const localVarPath = `/api/v1/authentication/sign-up`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(signUpDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authenticationControllerValidateEmail: async (token: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('authenticationControllerValidateEmail', 'token', token)
            const localVarPath = `/api/v1/authentication/validate-email`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthenticationApi - functional programming interface
 * @export
 */
export const AuthenticationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthenticationApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {AskResetPasswordDto} askResetPasswordDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authenticationControllerAskResetPassword(askResetPasswordDto: AskResetPasswordDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authenticationControllerAskResetPassword(askResetPasswordDto, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['AuthenticationApi.authenticationControllerAskResetPassword']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authenticationControllerCheckIfAuthenticated(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IsAuthenticatedDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authenticationControllerCheckIfAuthenticated(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['AuthenticationApi.authenticationControllerCheckIfAuthenticated']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} email 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authenticationControllerCheckIfEmailRegistered(email: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CheckIfEmailRegisteredResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authenticationControllerCheckIfEmailRegistered(email, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['AuthenticationApi.authenticationControllerCheckIfEmailRegistered']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authenticationControllerConfirmProfileEmailUpdate(token: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdatePersonalEmailResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authenticationControllerConfirmProfileEmailUpdate(token, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['AuthenticationApi.authenticationControllerConfirmProfileEmailUpdate']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {RefreshTokenDto} refreshTokenDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authenticationControllerRefreshTokens(refreshTokenDto: RefreshTokenDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccessTokensDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authenticationControllerRefreshTokens(refreshTokenDto, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['AuthenticationApi.authenticationControllerRefreshTokens']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authenticationControllerResendValidationEmail(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authenticationControllerResendValidationEmail(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['AuthenticationApi.authenticationControllerResendValidationEmail']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {ResetPasswordDto} resetPasswordDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authenticationControllerResetPassword(resetPasswordDto: ResetPasswordDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccessTokensDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authenticationControllerResetPassword(resetPasswordDto, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['AuthenticationApi.authenticationControllerResetPassword']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {SignInDto} signInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authenticationControllerSignIn(signInDto: SignInDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccessTokensDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authenticationControllerSignIn(signInDto, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['AuthenticationApi.authenticationControllerSignIn']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {SignOutDto} signOutDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authenticationControllerSignOut(signOutDto: SignOutDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authenticationControllerSignOut(signOutDto, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['AuthenticationApi.authenticationControllerSignOut']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {SignUpDto} signUpDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authenticationControllerSignUp(signUpDto: SignUpDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccessTokensDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authenticationControllerSignUp(signUpDto, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['AuthenticationApi.authenticationControllerSignUp']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authenticationControllerValidateEmail(token: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccessTokensDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authenticationControllerValidateEmail(token, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['AuthenticationApi.authenticationControllerValidateEmail']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * AuthenticationApi - factory interface
 * @export
 */
export const AuthenticationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthenticationApiFp(configuration)
    return {
        /**
         * 
         * @param {AskResetPasswordDto} askResetPasswordDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authenticationControllerAskResetPassword(askResetPasswordDto: AskResetPasswordDto, options?: any): AxiosPromise<void> {
            return localVarFp.authenticationControllerAskResetPassword(askResetPasswordDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authenticationControllerCheckIfAuthenticated(options?: any): AxiosPromise<IsAuthenticatedDto> {
            return localVarFp.authenticationControllerCheckIfAuthenticated(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} email 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authenticationControllerCheckIfEmailRegistered(email: string, options?: any): AxiosPromise<CheckIfEmailRegisteredResponseDto> {
            return localVarFp.authenticationControllerCheckIfEmailRegistered(email, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authenticationControllerConfirmProfileEmailUpdate(token: string, options?: any): AxiosPromise<UpdatePersonalEmailResponseDto> {
            return localVarFp.authenticationControllerConfirmProfileEmailUpdate(token, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {RefreshTokenDto} refreshTokenDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authenticationControllerRefreshTokens(refreshTokenDto: RefreshTokenDto, options?: any): AxiosPromise<AccessTokensDto> {
            return localVarFp.authenticationControllerRefreshTokens(refreshTokenDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authenticationControllerResendValidationEmail(options?: any): AxiosPromise<void> {
            return localVarFp.authenticationControllerResendValidationEmail(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ResetPasswordDto} resetPasswordDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authenticationControllerResetPassword(resetPasswordDto: ResetPasswordDto, options?: any): AxiosPromise<AccessTokensDto> {
            return localVarFp.authenticationControllerResetPassword(resetPasswordDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {SignInDto} signInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authenticationControllerSignIn(signInDto: SignInDto, options?: any): AxiosPromise<AccessTokensDto> {
            return localVarFp.authenticationControllerSignIn(signInDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {SignOutDto} signOutDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authenticationControllerSignOut(signOutDto: SignOutDto, options?: any): AxiosPromise<void> {
            return localVarFp.authenticationControllerSignOut(signOutDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {SignUpDto} signUpDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authenticationControllerSignUp(signUpDto: SignUpDto, options?: any): AxiosPromise<AccessTokensDto> {
            return localVarFp.authenticationControllerSignUp(signUpDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authenticationControllerValidateEmail(token: string, options?: any): AxiosPromise<AccessTokensDto> {
            return localVarFp.authenticationControllerValidateEmail(token, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthenticationApi - object-oriented interface
 * @export
 * @class AuthenticationApi
 * @extends {BaseAPI}
 */
export class AuthenticationApi extends BaseAPI {
    /**
     * 
     * @param {AskResetPasswordDto} askResetPasswordDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public authenticationControllerAskResetPassword(askResetPasswordDto: AskResetPasswordDto, options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).authenticationControllerAskResetPassword(askResetPasswordDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public authenticationControllerCheckIfAuthenticated(options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).authenticationControllerCheckIfAuthenticated(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} email 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public authenticationControllerCheckIfEmailRegistered(email: string, options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).authenticationControllerCheckIfEmailRegistered(email, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} token 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public authenticationControllerConfirmProfileEmailUpdate(token: string, options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).authenticationControllerConfirmProfileEmailUpdate(token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {RefreshTokenDto} refreshTokenDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public authenticationControllerRefreshTokens(refreshTokenDto: RefreshTokenDto, options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).authenticationControllerRefreshTokens(refreshTokenDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public authenticationControllerResendValidationEmail(options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).authenticationControllerResendValidationEmail(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ResetPasswordDto} resetPasswordDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public authenticationControllerResetPassword(resetPasswordDto: ResetPasswordDto, options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).authenticationControllerResetPassword(resetPasswordDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SignInDto} signInDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public authenticationControllerSignIn(signInDto: SignInDto, options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).authenticationControllerSignIn(signInDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SignOutDto} signOutDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public authenticationControllerSignOut(signOutDto: SignOutDto, options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).authenticationControllerSignOut(signOutDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SignUpDto} signUpDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public authenticationControllerSignUp(signUpDto: SignUpDto, options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).authenticationControllerSignUp(signUpDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} token 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public authenticationControllerValidateEmail(token: string, options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).authenticationControllerValidateEmail(token, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DocumentApi - axios parameter creator
 * @export
 */
export const DocumentApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {File} file Single PDF file under the &#x60;file&#x60; fieldname
         * @param {string} categoryId 
         * @param {Array<DocumentFilterValueDto>} filters 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentControllerCreate: async (file: File, categoryId: string, filters: Array<DocumentFilterValueDto>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'file' is not null or undefined
            assertParamExists('documentControllerCreate', 'file', file)
            // verify required parameter 'categoryId' is not null or undefined
            assertParamExists('documentControllerCreate', 'categoryId', categoryId)
            // verify required parameter 'filters' is not null or undefined
            assertParamExists('documentControllerCreate', 'filters', filters)
            const localVarPath = `/api/v1/document`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
            if (categoryId !== undefined) { 
                localVarFormParams.append('categoryId', categoryId as any);
            }
                if (filters) {
                localVarFormParams.append('filters', filters.join(COLLECTION_FORMATS.csv));
            }

    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentControllerFindAll: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/document`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentControllerFindOne: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('documentControllerFindOne', 'id', id)
            const localVarPath = `/api/v1/document/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentControllerGetFavoriteDocumentIds: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/document/favorites-ids`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentControllerGetFavoriteDocuments: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/document/favorites`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentControllerGetIndexationStatus: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('documentControllerGetIndexationStatus', 'id', id)
            const localVarPath = `/api/v1/document/indexation-status/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentControllerMarkAsFavorite: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('documentControllerMarkAsFavorite', 'id', id)
            const localVarPath = `/api/v1/document/mark-as-favorite/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {DeleteDocumentsDto} deleteDocumentsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentControllerRemove: async (deleteDocumentsDto: DeleteDocumentsDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'deleteDocumentsDto' is not null or undefined
            assertParamExists('documentControllerRemove', 'deleteDocumentsDto', deleteDocumentsDto)
            const localVarPath = `/api/v1/document`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deleteDocumentsDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentControllerRemoveFromFavorites: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('documentControllerRemoveFromFavorites', 'id', id)
            const localVarPath = `/api/v1/document/remove-from-favorites/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {UpdateDocumentDto} updateDocumentDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentControllerUpdate: async (updateDocumentDto: UpdateDocumentDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'updateDocumentDto' is not null or undefined
            assertParamExists('documentControllerUpdate', 'updateDocumentDto', updateDocumentDto)
            const localVarPath = `/api/v1/document`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateDocumentDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DocumentApi - functional programming interface
 * @export
 */
export const DocumentApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DocumentApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {File} file Single PDF file under the &#x60;file&#x60; fieldname
         * @param {string} categoryId 
         * @param {Array<DocumentFilterValueDto>} filters 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentControllerCreate(file: File, categoryId: string, filters: Array<DocumentFilterValueDto>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateDocumentResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentControllerCreate(file, categoryId, filters, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DocumentApi.documentControllerCreate']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentControllerFindAll(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentControllerFindAll(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DocumentApi.documentControllerFindAll']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentControllerFindOne(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentControllerFindOne(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DocumentApi.documentControllerFindOne']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentControllerGetFavoriteDocumentIds(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentControllerGetFavoriteDocumentIds(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DocumentApi.documentControllerGetFavoriteDocumentIds']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentControllerGetFavoriteDocuments(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SearchResultDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentControllerGetFavoriteDocuments(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DocumentApi.documentControllerGetFavoriteDocuments']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentControllerGetIndexationStatus(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IndexationStatusDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentControllerGetIndexationStatus(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DocumentApi.documentControllerGetIndexationStatus']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentControllerMarkAsFavorite(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentControllerMarkAsFavorite(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DocumentApi.documentControllerMarkAsFavorite']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {DeleteDocumentsDto} deleteDocumentsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentControllerRemove(deleteDocumentsDto: DeleteDocumentsDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentControllerRemove(deleteDocumentsDto, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DocumentApi.documentControllerRemove']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentControllerRemoveFromFavorites(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentControllerRemoveFromFavorites(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DocumentApi.documentControllerRemoveFromFavorites']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {UpdateDocumentDto} updateDocumentDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentControllerUpdate(updateDocumentDto: UpdateDocumentDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SearchResultDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentControllerUpdate(updateDocumentDto, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DocumentApi.documentControllerUpdate']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * DocumentApi - factory interface
 * @export
 */
export const DocumentApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DocumentApiFp(configuration)
    return {
        /**
         * 
         * @param {File} file Single PDF file under the &#x60;file&#x60; fieldname
         * @param {string} categoryId 
         * @param {Array<DocumentFilterValueDto>} filters 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentControllerCreate(file: File, categoryId: string, filters: Array<DocumentFilterValueDto>, options?: any): AxiosPromise<CreateDocumentResponseDto> {
            return localVarFp.documentControllerCreate(file, categoryId, filters, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentControllerFindAll(options?: any): AxiosPromise<string> {
            return localVarFp.documentControllerFindAll(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentControllerFindOne(id: string, options?: any): AxiosPromise<string> {
            return localVarFp.documentControllerFindOne(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentControllerGetFavoriteDocumentIds(options?: any): AxiosPromise<Array<string>> {
            return localVarFp.documentControllerGetFavoriteDocumentIds(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentControllerGetFavoriteDocuments(options?: any): AxiosPromise<Array<SearchResultDto>> {
            return localVarFp.documentControllerGetFavoriteDocuments(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentControllerGetIndexationStatus(id: string, options?: any): AxiosPromise<IndexationStatusDto> {
            return localVarFp.documentControllerGetIndexationStatus(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentControllerMarkAsFavorite(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.documentControllerMarkAsFavorite(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {DeleteDocumentsDto} deleteDocumentsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentControllerRemove(deleteDocumentsDto: DeleteDocumentsDto, options?: any): AxiosPromise<void> {
            return localVarFp.documentControllerRemove(deleteDocumentsDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentControllerRemoveFromFavorites(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.documentControllerRemoveFromFavorites(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {UpdateDocumentDto} updateDocumentDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentControllerUpdate(updateDocumentDto: UpdateDocumentDto, options?: any): AxiosPromise<Array<SearchResultDto>> {
            return localVarFp.documentControllerUpdate(updateDocumentDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DocumentApi - object-oriented interface
 * @export
 * @class DocumentApi
 * @extends {BaseAPI}
 */
export class DocumentApi extends BaseAPI {
    /**
     * 
     * @param {File} file Single PDF file under the &#x60;file&#x60; fieldname
     * @param {string} categoryId 
     * @param {Array<DocumentFilterValueDto>} filters 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentApi
     */
    public documentControllerCreate(file: File, categoryId: string, filters: Array<DocumentFilterValueDto>, options?: RawAxiosRequestConfig) {
        return DocumentApiFp(this.configuration).documentControllerCreate(file, categoryId, filters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentApi
     */
    public documentControllerFindAll(options?: RawAxiosRequestConfig) {
        return DocumentApiFp(this.configuration).documentControllerFindAll(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentApi
     */
    public documentControllerFindOne(id: string, options?: RawAxiosRequestConfig) {
        return DocumentApiFp(this.configuration).documentControllerFindOne(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentApi
     */
    public documentControllerGetFavoriteDocumentIds(options?: RawAxiosRequestConfig) {
        return DocumentApiFp(this.configuration).documentControllerGetFavoriteDocumentIds(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentApi
     */
    public documentControllerGetFavoriteDocuments(options?: RawAxiosRequestConfig) {
        return DocumentApiFp(this.configuration).documentControllerGetFavoriteDocuments(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentApi
     */
    public documentControllerGetIndexationStatus(id: string, options?: RawAxiosRequestConfig) {
        return DocumentApiFp(this.configuration).documentControllerGetIndexationStatus(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentApi
     */
    public documentControllerMarkAsFavorite(id: string, options?: RawAxiosRequestConfig) {
        return DocumentApiFp(this.configuration).documentControllerMarkAsFavorite(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DeleteDocumentsDto} deleteDocumentsDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentApi
     */
    public documentControllerRemove(deleteDocumentsDto: DeleteDocumentsDto, options?: RawAxiosRequestConfig) {
        return DocumentApiFp(this.configuration).documentControllerRemove(deleteDocumentsDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentApi
     */
    public documentControllerRemoveFromFavorites(id: string, options?: RawAxiosRequestConfig) {
        return DocumentApiFp(this.configuration).documentControllerRemoveFromFavorites(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UpdateDocumentDto} updateDocumentDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentApi
     */
    public documentControllerUpdate(updateDocumentDto: UpdateDocumentDto, options?: RawAxiosRequestConfig) {
        return DocumentApiFp(this.configuration).documentControllerUpdate(updateDocumentDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * FiltersApi - axios parameter creator
 * @export
 */
export const FiltersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CreateFilterDto} createFilterDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filtersControllerCreate: async (createFilterDto: CreateFilterDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createFilterDto' is not null or undefined
            assertParamExists('filtersControllerCreate', 'createFilterDto', createFilterDto)
            const localVarPath = `/api/v1/filters`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createFilterDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [query] 
         * @param {string} [groupsOnly] 
         * @param {string} [categoryId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filtersControllerFindAll: async (query?: string, groupsOnly?: string, categoryId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/filters`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (groupsOnly !== undefined) {
                localVarQueryParameter['groupsOnly'] = groupsOnly;
            }

            if (categoryId !== undefined) {
                localVarQueryParameter['categoryId'] = categoryId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filtersControllerFindOne: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('filtersControllerFindOne', 'id', id)
            const localVarPath = `/api/v1/filters/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filtersControllerGetCategories: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/filters/categories`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} categoryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filtersControllerGetFiltersTree: async (categoryId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'categoryId' is not null or undefined
            assertParamExists('filtersControllerGetFiltersTree', 'categoryId', categoryId)
            const localVarPath = `/api/v1/filters/tree`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (categoryId !== undefined) {
                localVarQueryParameter['categoryId'] = categoryId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filtersControllerRemove: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('filtersControllerRemove', 'id', id)
            const localVarPath = `/api/v1/filters/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateFilterDto} updateFilterDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filtersControllerUpdate: async (id: string, updateFilterDto: UpdateFilterDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('filtersControllerUpdate', 'id', id)
            // verify required parameter 'updateFilterDto' is not null or undefined
            assertParamExists('filtersControllerUpdate', 'updateFilterDto', updateFilterDto)
            const localVarPath = `/api/v1/filters/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateFilterDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FiltersApi - functional programming interface
 * @export
 */
export const FiltersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FiltersApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {CreateFilterDto} createFilterDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async filtersControllerCreate(createFilterDto: CreateFilterDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.filtersControllerCreate(createFilterDto, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['FiltersApi.filtersControllerCreate']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} [query] 
         * @param {string} [groupsOnly] 
         * @param {string} [categoryId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async filtersControllerFindAll(query?: string, groupsOnly?: string, categoryId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<FilterDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.filtersControllerFindAll(query, groupsOnly, categoryId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['FiltersApi.filtersControllerFindAll']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async filtersControllerFindOne(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.filtersControllerFindOne(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['FiltersApi.filtersControllerFindOne']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async filtersControllerGetCategories(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CategoryDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.filtersControllerGetCategories(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['FiltersApi.filtersControllerGetCategories']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} categoryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async filtersControllerGetFiltersTree(categoryId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FilterGroupWithMappingDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.filtersControllerGetFiltersTree(categoryId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['FiltersApi.filtersControllerGetFiltersTree']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async filtersControllerRemove(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.filtersControllerRemove(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['FiltersApi.filtersControllerRemove']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateFilterDto} updateFilterDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async filtersControllerUpdate(id: string, updateFilterDto: UpdateFilterDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.filtersControllerUpdate(id, updateFilterDto, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['FiltersApi.filtersControllerUpdate']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * FiltersApi - factory interface
 * @export
 */
export const FiltersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FiltersApiFp(configuration)
    return {
        /**
         * 
         * @param {CreateFilterDto} createFilterDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filtersControllerCreate(createFilterDto: CreateFilterDto, options?: any): AxiosPromise<void> {
            return localVarFp.filtersControllerCreate(createFilterDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [query] 
         * @param {string} [groupsOnly] 
         * @param {string} [categoryId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filtersControllerFindAll(query?: string, groupsOnly?: string, categoryId?: string, options?: any): AxiosPromise<Array<FilterDto>> {
            return localVarFp.filtersControllerFindAll(query, groupsOnly, categoryId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filtersControllerFindOne(id: string, options?: any): AxiosPromise<string> {
            return localVarFp.filtersControllerFindOne(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filtersControllerGetCategories(options?: any): AxiosPromise<Array<CategoryDto>> {
            return localVarFp.filtersControllerGetCategories(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} categoryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filtersControllerGetFiltersTree(categoryId: string, options?: any): AxiosPromise<FilterGroupWithMappingDto> {
            return localVarFp.filtersControllerGetFiltersTree(categoryId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filtersControllerRemove(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.filtersControllerRemove(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateFilterDto} updateFilterDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filtersControllerUpdate(id: string, updateFilterDto: UpdateFilterDto, options?: any): AxiosPromise<void> {
            return localVarFp.filtersControllerUpdate(id, updateFilterDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FiltersApi - object-oriented interface
 * @export
 * @class FiltersApi
 * @extends {BaseAPI}
 */
export class FiltersApi extends BaseAPI {
    /**
     * 
     * @param {CreateFilterDto} createFilterDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FiltersApi
     */
    public filtersControllerCreate(createFilterDto: CreateFilterDto, options?: RawAxiosRequestConfig) {
        return FiltersApiFp(this.configuration).filtersControllerCreate(createFilterDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [query] 
     * @param {string} [groupsOnly] 
     * @param {string} [categoryId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FiltersApi
     */
    public filtersControllerFindAll(query?: string, groupsOnly?: string, categoryId?: string, options?: RawAxiosRequestConfig) {
        return FiltersApiFp(this.configuration).filtersControllerFindAll(query, groupsOnly, categoryId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FiltersApi
     */
    public filtersControllerFindOne(id: string, options?: RawAxiosRequestConfig) {
        return FiltersApiFp(this.configuration).filtersControllerFindOne(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FiltersApi
     */
    public filtersControllerGetCategories(options?: RawAxiosRequestConfig) {
        return FiltersApiFp(this.configuration).filtersControllerGetCategories(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} categoryId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FiltersApi
     */
    public filtersControllerGetFiltersTree(categoryId: string, options?: RawAxiosRequestConfig) {
        return FiltersApiFp(this.configuration).filtersControllerGetFiltersTree(categoryId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FiltersApi
     */
    public filtersControllerRemove(id: string, options?: RawAxiosRequestConfig) {
        return FiltersApiFp(this.configuration).filtersControllerRemove(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {UpdateFilterDto} updateFilterDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FiltersApi
     */
    public filtersControllerUpdate(id: string, updateFilterDto: UpdateFilterDto, options?: RawAxiosRequestConfig) {
        return FiltersApiFp(this.configuration).filtersControllerUpdate(id, updateFilterDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SearchApi - axios parameter creator
 * @export
 */
export const SearchApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchControllerDeleteSavedSearchQuery: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('searchControllerDeleteSavedSearchQuery', 'id', id)
            const localVarPath = `/api/v1/search/saved-searches/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {DocumentExportRequestDto} documentExportRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchControllerExportSearchResult: async (documentExportRequestDto: DocumentExportRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'documentExportRequestDto' is not null or undefined
            assertParamExists('searchControllerExportSearchResult', 'documentExportRequestDto', documentExportRequestDto)
            const localVarPath = `/api/v1/search/export`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(documentExportRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchControllerGetSavedSearch: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('searchControllerGetSavedSearch', 'id', id)
            const localVarPath = `/api/v1/search/saved-search/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchControllerGetSavedSearchQueries: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/search/saved-searches`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Array<ImageDto>} [savedImages] Pre-saved images (same format as in db, contain embeddings)
         * @param {Array<File>} [imageFiles] Multiple images files under the &#x60;imageFiles&#x60; fieldname
         * @param {Array<SearchQueryDtoFilterValuesInner>} [filterValues] 
         * @param {string} [text] 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {string} [categoryId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchControllerSaveSearchQuery: async (savedImages?: Array<ImageDto>, imageFiles?: Array<File>, filterValues?: Array<SearchQueryDtoFilterValuesInner>, text?: string, limit?: number, offset?: number, categoryId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/search/save`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            if (savedImages) {
                localVarFormParams.append('savedImages', savedImages.join(COLLECTION_FORMATS.csv));
            }

                if (imageFiles) {
                imageFiles.forEach((element) => {
                    localVarFormParams.append('imageFiles', element as any);
                })
            }

                if (filterValues) {
                localVarFormParams.append('filterValues', filterValues.join(COLLECTION_FORMATS.csv));
            }

    
            if (text !== undefined) { 
                localVarFormParams.append('text', text as any);
            }
    
            if (limit !== undefined) { 
                localVarFormParams.append('limit', limit as any);
            }
    
            if (offset !== undefined) { 
                localVarFormParams.append('offset', offset as any);
            }
    
            if (categoryId !== undefined) { 
                localVarFormParams.append('categoryId', categoryId as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Array<ImageDto>} [savedImages] Pre-saved images (same format as in db, contain embeddings)
         * @param {Array<File>} [imageFiles] Multiple images files under the &#x60;imageFiles&#x60; fieldname
         * @param {Array<SearchQueryDtoFilterValuesInner>} [filterValues] 
         * @param {string} [text] 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {string} [categoryId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchControllerSearch: async (savedImages?: Array<ImageDto>, imageFiles?: Array<File>, filterValues?: Array<SearchQueryDtoFilterValuesInner>, text?: string, limit?: number, offset?: number, categoryId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            if (savedImages) {
                localVarFormParams.append('savedImages', savedImages.join(COLLECTION_FORMATS.csv));
            }

                if (imageFiles) {
                imageFiles.forEach((element) => {
                    localVarFormParams.append('imageFiles', element as any);
                })
            }

                if (filterValues) {
                localVarFormParams.append('filterValues', filterValues.join(COLLECTION_FORMATS.csv));
            }

    
            if (text !== undefined) { 
                localVarFormParams.append('text', text as any);
            }
    
            if (limit !== undefined) { 
                localVarFormParams.append('limit', limit as any);
            }
    
            if (offset !== undefined) { 
                localVarFormParams.append('offset', offset as any);
            }
    
            if (categoryId !== undefined) { 
                localVarFormParams.append('categoryId', categoryId as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateSavedSearchDto} updateSavedSearchDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchControllerUpdateSavedSearch: async (id: string, updateSavedSearchDto: UpdateSavedSearchDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('searchControllerUpdateSavedSearch', 'id', id)
            // verify required parameter 'updateSavedSearchDto' is not null or undefined
            assertParamExists('searchControllerUpdateSavedSearch', 'updateSavedSearchDto', updateSavedSearchDto)
            const localVarPath = `/api/v1/search/saved-searches/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateSavedSearchDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Array<File>} imageFiles Multiple images files under the &#x60;imageFiles&#x60; fieldname
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchControllerUploadJunkImages: async (imageFiles: Array<File>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'imageFiles' is not null or undefined
            assertParamExists('searchControllerUploadJunkImages', 'imageFiles', imageFiles)
            const localVarPath = `/api/v1/search/upload-junk-images`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            if (imageFiles) {
                imageFiles.forEach((element) => {
                    localVarFormParams.append('imageFiles', element as any);
                })
            }

    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SearchApi - functional programming interface
 * @export
 */
export const SearchApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SearchApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchControllerDeleteSavedSearchQuery(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchControllerDeleteSavedSearchQuery(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['SearchApi.searchControllerDeleteSavedSearchQuery']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {DocumentExportRequestDto} documentExportRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchControllerExportSearchResult(documentExportRequestDto: DocumentExportRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchControllerExportSearchResult(documentExportRequestDto, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['SearchApi.searchControllerExportSearchResult']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchControllerGetSavedSearch(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SavedSearchDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchControllerGetSavedSearch(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['SearchApi.searchControllerGetSavedSearch']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchControllerGetSavedSearchQueries(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SavedSearchDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchControllerGetSavedSearchQueries(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['SearchApi.searchControllerGetSavedSearchQueries']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {Array<ImageDto>} [savedImages] Pre-saved images (same format as in db, contain embeddings)
         * @param {Array<File>} [imageFiles] Multiple images files under the &#x60;imageFiles&#x60; fieldname
         * @param {Array<SearchQueryDtoFilterValuesInner>} [filterValues] 
         * @param {string} [text] 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {string} [categoryId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchControllerSaveSearchQuery(savedImages?: Array<ImageDto>, imageFiles?: Array<File>, filterValues?: Array<SearchQueryDtoFilterValuesInner>, text?: string, limit?: number, offset?: number, categoryId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateSavedSearchResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchControllerSaveSearchQuery(savedImages, imageFiles, filterValues, text, limit, offset, categoryId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['SearchApi.searchControllerSaveSearchQuery']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {Array<ImageDto>} [savedImages] Pre-saved images (same format as in db, contain embeddings)
         * @param {Array<File>} [imageFiles] Multiple images files under the &#x60;imageFiles&#x60; fieldname
         * @param {Array<SearchQueryDtoFilterValuesInner>} [filterValues] 
         * @param {string} [text] 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {string} [categoryId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchControllerSearch(savedImages?: Array<ImageDto>, imageFiles?: Array<File>, filterValues?: Array<SearchQueryDtoFilterValuesInner>, text?: string, limit?: number, offset?: number, categoryId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SearchResultsWithRefinementFiltersDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchControllerSearch(savedImages, imageFiles, filterValues, text, limit, offset, categoryId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['SearchApi.searchControllerSearch']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateSavedSearchDto} updateSavedSearchDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchControllerUpdateSavedSearch(id: string, updateSavedSearchDto: UpdateSavedSearchDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchControllerUpdateSavedSearch(id, updateSavedSearchDto, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['SearchApi.searchControllerUpdateSavedSearch']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {Array<File>} imageFiles Multiple images files under the &#x60;imageFiles&#x60; fieldname
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchControllerUploadJunkImages(imageFiles: Array<File>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchControllerUploadJunkImages(imageFiles, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['SearchApi.searchControllerUploadJunkImages']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * SearchApi - factory interface
 * @export
 */
export const SearchApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SearchApiFp(configuration)
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchControllerDeleteSavedSearchQuery(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.searchControllerDeleteSavedSearchQuery(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {DocumentExportRequestDto} documentExportRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchControllerExportSearchResult(documentExportRequestDto: DocumentExportRequestDto, options?: any): AxiosPromise<string> {
            return localVarFp.searchControllerExportSearchResult(documentExportRequestDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchControllerGetSavedSearch(id: string, options?: any): AxiosPromise<SavedSearchDto> {
            return localVarFp.searchControllerGetSavedSearch(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchControllerGetSavedSearchQueries(options?: any): AxiosPromise<Array<SavedSearchDto>> {
            return localVarFp.searchControllerGetSavedSearchQueries(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Array<ImageDto>} [savedImages] Pre-saved images (same format as in db, contain embeddings)
         * @param {Array<File>} [imageFiles] Multiple images files under the &#x60;imageFiles&#x60; fieldname
         * @param {Array<SearchQueryDtoFilterValuesInner>} [filterValues] 
         * @param {string} [text] 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {string} [categoryId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchControllerSaveSearchQuery(savedImages?: Array<ImageDto>, imageFiles?: Array<File>, filterValues?: Array<SearchQueryDtoFilterValuesInner>, text?: string, limit?: number, offset?: number, categoryId?: string, options?: any): AxiosPromise<CreateSavedSearchResponseDto> {
            return localVarFp.searchControllerSaveSearchQuery(savedImages, imageFiles, filterValues, text, limit, offset, categoryId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Array<ImageDto>} [savedImages] Pre-saved images (same format as in db, contain embeddings)
         * @param {Array<File>} [imageFiles] Multiple images files under the &#x60;imageFiles&#x60; fieldname
         * @param {Array<SearchQueryDtoFilterValuesInner>} [filterValues] 
         * @param {string} [text] 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {string} [categoryId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchControllerSearch(savedImages?: Array<ImageDto>, imageFiles?: Array<File>, filterValues?: Array<SearchQueryDtoFilterValuesInner>, text?: string, limit?: number, offset?: number, categoryId?: string, options?: any): AxiosPromise<SearchResultsWithRefinementFiltersDto> {
            return localVarFp.searchControllerSearch(savedImages, imageFiles, filterValues, text, limit, offset, categoryId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateSavedSearchDto} updateSavedSearchDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchControllerUpdateSavedSearch(id: string, updateSavedSearchDto: UpdateSavedSearchDto, options?: any): AxiosPromise<void> {
            return localVarFp.searchControllerUpdateSavedSearch(id, updateSavedSearchDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Array<File>} imageFiles Multiple images files under the &#x60;imageFiles&#x60; fieldname
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchControllerUploadJunkImages(imageFiles: Array<File>, options?: any): AxiosPromise<void> {
            return localVarFp.searchControllerUploadJunkImages(imageFiles, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SearchApi - object-oriented interface
 * @export
 * @class SearchApi
 * @extends {BaseAPI}
 */
export class SearchApi extends BaseAPI {
    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SearchApi
     */
    public searchControllerDeleteSavedSearchQuery(id: string, options?: RawAxiosRequestConfig) {
        return SearchApiFp(this.configuration).searchControllerDeleteSavedSearchQuery(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DocumentExportRequestDto} documentExportRequestDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SearchApi
     */
    public searchControllerExportSearchResult(documentExportRequestDto: DocumentExportRequestDto, options?: RawAxiosRequestConfig) {
        return SearchApiFp(this.configuration).searchControllerExportSearchResult(documentExportRequestDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SearchApi
     */
    public searchControllerGetSavedSearch(id: string, options?: RawAxiosRequestConfig) {
        return SearchApiFp(this.configuration).searchControllerGetSavedSearch(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SearchApi
     */
    public searchControllerGetSavedSearchQueries(options?: RawAxiosRequestConfig) {
        return SearchApiFp(this.configuration).searchControllerGetSavedSearchQueries(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Array<ImageDto>} [savedImages] Pre-saved images (same format as in db, contain embeddings)
     * @param {Array<File>} [imageFiles] Multiple images files under the &#x60;imageFiles&#x60; fieldname
     * @param {Array<SearchQueryDtoFilterValuesInner>} [filterValues] 
     * @param {string} [text] 
     * @param {number} [limit] 
     * @param {number} [offset] 
     * @param {string} [categoryId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SearchApi
     */
    public searchControllerSaveSearchQuery(savedImages?: Array<ImageDto>, imageFiles?: Array<File>, filterValues?: Array<SearchQueryDtoFilterValuesInner>, text?: string, limit?: number, offset?: number, categoryId?: string, options?: RawAxiosRequestConfig) {
        return SearchApiFp(this.configuration).searchControllerSaveSearchQuery(savedImages, imageFiles, filterValues, text, limit, offset, categoryId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Array<ImageDto>} [savedImages] Pre-saved images (same format as in db, contain embeddings)
     * @param {Array<File>} [imageFiles] Multiple images files under the &#x60;imageFiles&#x60; fieldname
     * @param {Array<SearchQueryDtoFilterValuesInner>} [filterValues] 
     * @param {string} [text] 
     * @param {number} [limit] 
     * @param {number} [offset] 
     * @param {string} [categoryId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SearchApi
     */
    public searchControllerSearch(savedImages?: Array<ImageDto>, imageFiles?: Array<File>, filterValues?: Array<SearchQueryDtoFilterValuesInner>, text?: string, limit?: number, offset?: number, categoryId?: string, options?: RawAxiosRequestConfig) {
        return SearchApiFp(this.configuration).searchControllerSearch(savedImages, imageFiles, filterValues, text, limit, offset, categoryId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {UpdateSavedSearchDto} updateSavedSearchDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SearchApi
     */
    public searchControllerUpdateSavedSearch(id: string, updateSavedSearchDto: UpdateSavedSearchDto, options?: RawAxiosRequestConfig) {
        return SearchApiFp(this.configuration).searchControllerUpdateSavedSearch(id, updateSavedSearchDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Array<File>} imageFiles Multiple images files under the &#x60;imageFiles&#x60; fieldname
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SearchApi
     */
    public searchControllerUploadJunkImages(imageFiles: Array<File>, options?: RawAxiosRequestConfig) {
        return SearchApiFp(this.configuration).searchControllerUploadJunkImages(imageFiles, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UserApi - axios parameter creator
 * @export
 */
export const UserApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerGetUser: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {UpdateUserProfileDto} updateUserProfileDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerUpdateProfile: async (updateUserProfileDto: UpdateUserProfileDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'updateUserProfileDto' is not null or undefined
            assertParamExists('userControllerUpdateProfile', 'updateUserProfileDto', updateUserProfileDto)
            const localVarPath = `/api/v1/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateUserProfileDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserApi - functional programming interface
 * @export
 */
export const UserApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userControllerGetUser(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserProfileDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userControllerGetUser(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UserApi.userControllerGetUser']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {UpdateUserProfileDto} updateUserProfileDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userControllerUpdateProfile(updateUserProfileDto: UpdateUserProfileDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateUserProfileResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userControllerUpdateProfile(updateUserProfileDto, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UserApi.userControllerUpdateProfile']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * UserApi - factory interface
 * @export
 */
export const UserApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerGetUser(options?: any): AxiosPromise<UserProfileDto> {
            return localVarFp.userControllerGetUser(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {UpdateUserProfileDto} updateUserProfileDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerUpdateProfile(updateUserProfileDto: UpdateUserProfileDto, options?: any): AxiosPromise<UpdateUserProfileResponseDto> {
            return localVarFp.userControllerUpdateProfile(updateUserProfileDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
export class UserApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userControllerGetUser(options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).userControllerGetUser(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UpdateUserProfileDto} updateUserProfileDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userControllerUpdateProfile(updateUserProfileDto: UpdateUserProfileDto, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).userControllerUpdateProfile(updateUserProfileDto, options).then((request) => request(this.axios, this.basePath));
    }
}



